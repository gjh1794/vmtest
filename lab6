Fork:
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main() {
	int fd[2];
	pipe(fd);
	while(1) {
		char input[1000];
		char cypher[1000];
		char xor = 'g';
		printf(">>");
		fgets(input, 1000, stdin);
		char esc[] = "exit\n";
		if(strcmp(input, esc) == 0) {
			break;
		}
		printf("%s\n", input); 
		//printf("I'm parent.\n");
		for(int z = 0; z < 1000; z++) {
			if(input[z] == '\0') {
				cypher[z] = '\0';
				break;
			}
			char cypchar = input[z] ^ xor;
			cypher[z] = cypchar;
		}
		write(fd[1], cypher, 1000);
		pid_t pid = fork();
		if(pid < 0) {
			printf("fork failed.\n");
			exit(1);
		}
		else if(pid == 0) {
			//in child process
			char input2[1000];
			read(fd[0], input2, 1000);
			printf("%s\n", input2);
			char* argvec[] = {"./filewrite", input2, NULL};
			if(execv(argvec[0], argvec) < 0) {
				printf("Exec Fails.\n");
				exit(1);
			}
			printf("end of exec.\n");
		}
		wait(NULL);
		printf("Parent process is doing something here.\n");
	}
	return 0;
}

Filewrite:
#include<stdio.h>
#include<unistd.h>

int main(int argc, char* argv[]) {
	char xor = 'g';
	char* cypher = argv[1];
	char pt[1000];
	for(int z = 0; z < 1000; z++) {
		if(cypher[z] == '\0') {
			break;
		}
		char ptchar = cypher[z] ^ xor;
		pt[z] = ptchar;
	}
	FILE* fp = fopen("plaintext.txt", "w+");
	fprintf(fp, "%s\n", pt);
	fprintf(fp, "End of message\n");
	fclose(fp);
	return 0;
}
